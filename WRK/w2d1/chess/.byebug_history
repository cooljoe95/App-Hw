q
self.board.in_check?(:black)
display final_locs
display dir
q
self.board.in_check?(:blackq)
self.board.in_check?(:black)
board.in_bounds?([x, y]) && board.grid[x][y].color != self.color
self.board.send(:find_king, :black)
display [x, y]
display final_locs
display dir
q
self.board.send(:find_king, :black)
self.board[[2, 4]].moves
self.board.in_check?(:black)
self.pos
c
display dir
c
display final_locs
n
 board.in_bounds?([x, y]) && board.grid[x][y].color != self.color
dir
self.class
[x,y]
q
c
q
final_locs
n
[x, y]
x
p x
q
self.board[[1,4]]
[x,y]
q
s
board.in_bounds?([x,y])
dir
q
n
self.pos
self.class
final_locs
q
c
q
list
rook.moves
rook = new_board[[2, 4]]
new_board.grid.map { |row| p row.map { |piece| piece.class }  }
new_board.grid.map { |row| row.map { |piece| piece.class }  }
new_board[[2, 4]].moves
new_board[[2, 4]].class
new_board.send(:find_king, :black)
new_board.find_king(:black)
new_board.find_king?(:black)
new_board.in_check?(:white)
new_board.in_check?(:black)
new_board.in_check?
puts new_board.grid.map { |row| row.map { |piece| piece.class }  }
new_board[[1,4]]
n
c
self
self.moves
c
q
move_into_check?([1,4])
self.moves
c
self
c
quit
piece.valid_moves
self.valid_moves
piece = self[start_pos]
n
s
n
s
n
c
n
s
self.moves
self
n
s
n
 self[start_pos].valid_moves.include?(end_pos)
c
q
c
